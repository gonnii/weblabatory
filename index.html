<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="main.css">
  <title>Landing Page</title>
  <script type="importmap">
  {
    "imports": {
      "three": "./build/three.module.js",
      "three/addons/": "./jsm/",
      "three/shaders/UniformsLib": "./build/shaders/UniformsLib.js",
      "three/math/Color.js": "./jsm/math/Color.js",
      "three/math/Vector2.js": "./jsm/math/Vector2.js",
      "three/math/Matrix3.js": "./jsm/math/Matrix3.js"
    }
  }
  </script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="scene-container">
    <div id="info" class="custom-info">
      A lab for documenting immersive web experiments
    <div class="description-text">
      Drag to rotate the lab 360 <br> Click the wooden sculpture to look inside
  </div>
</div>

  </div>
  <script type="module">
    import { Scene, PerspectiveCamera, WebGLRenderer, Vector3, TextureLoader, RepeatWrapping, SphereGeometry, MeshPhysicalMaterial, Mesh, DirectionalLight, MathUtils, Box3, Sphere, PointLight, Vector2, EquirectangularReflectionMapping, PlaneGeometry, MeshBasicMaterial, PointsMaterial, Points, Raycaster, ShaderMaterial, Color, BufferGeometry, BufferAttribute} from 'three';;
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from './jsm/loaders/RGBELoader.js';
    import { XYZLoader } from './jsm/loaders/XYZLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    let camera, scene, renderer, controls, sun;
    let composer, bloomPass;
    let points, water = null;
    let particles, count = 0;
    const SEPARATION = 15, AMOUNTX = 300, AMOUNTY = 300;

    function init() {
      // Scene, Camera, Renderer
      scene = new Scene();
      camera = new PerspectiveCamera(55, window.innerWidth / window.innerHeight, 10, 5000);
      camera.position.set(9, 12, 300);
      camera.layers.enable(1);

      renderer = new WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('scene-container').appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableZoom = false; // ì¤Œ ë¹„í™œì„±í™”
      controls.enablePan = false; // ì´ë™ ë¹„í™œì„±í™” (ì´ë™í•˜ë©´ 360ë„ ì œí•œì´ ê¹¨ì§)
      controls.minPolarAngle = 0.0; // ìœ„ìª½ ì œí•œ
      controls.maxPolarAngle = Math.PI / 2.1; // ì•„ë˜ìª½ ì œí•œ
      controls.minDistance = 50;  
      controls.maxDistance = 300;
      controls.update();

      const raycaster = new Raycaster();
      const mouse = new Vector2();

      // Light
      sun = new Vector3();
      const light = new DirectionalLight(0xffffff, 1);
      light.position.set(100, 100, 100);
      scene.add(light);

      // (3) HDR ë¡œë”
      const hdrLoader = new RGBELoader();
      hdrLoader.load('./textures/hdrimage.hdr', function (hdrMap) { //
      hdrMap.mapping = EquirectangularReflectionMapping;
      scene.environment = hdrMap; 

      // Sky
      const sky = new Sky();
      sky.scale.setScalar(10000);
      scene.add(sky);

      // Sky uniforms ì„¤ì •
      sky.material.uniforms.turbidity.value = 0.25;
      sky.material.uniforms.rayleigh.value = 0.744;
      sky.material.uniforms.mieCoefficient.value = 0.12;
      sky.material.uniforms.mieDirectionalG.value = 6.99;

      // elevation(ê³ ë„)ì™€ azimuth(ë°©ìœ„ê°)
      const elevation = 15.0;
      const azimuth = 200;

      // ê°ë„ â†’ ë¼ë””ì•ˆ ë³€í™˜
      const phi = MathUtils.degToRad(90 - elevation);
      const theta = MathUtils.degToRad(azimuth);

      // sunì€ Vector3
      sun.setFromSphericalCoords(1, phi, theta);
      sky.material.uniforms.sunPosition.value.copy(sun);

      // í†¤ ë§¤í•‘ ë…¸ì¶œ (exposure)
      renderer.toneMappingExposure = 0.6093; // ìš”ì²­ ê°’ì— ë§ì¶° ì¡°ì ˆ

      // Water
      const waterGeometry = new PlaneGeometry(10000, 10000);
      water = new Water(
        waterGeometry,
        {
          textureWidth: 712,
          textureHeight: 712,
          waterNormals: new TextureLoader().load('./textures/waternormals.jpg', function (texture) {
            texture.wrapS = texture.wrapT = RepeatWrapping;
          }),
          alpha: 1.0,
          sunDirection: sun.clone().normalize(),
          sunColor: 0xffffff,
          waterColor: 0x001e0f,
          distortionScale: 2.7,
          fog: scene.fog !== undefined
        }
      ); //
      water.rotation.x = -Math.PI / 2;
      scene.add(water);
      water.material.uniforms.distortionScale.value = 0.1; // âœ… ë°˜ì‚¬ ì™œê³¡ ì¤„ì´ê¸°
      water.material.uniforms.sunColor.value.set(0xbbbbbb); // âœ… ë°˜ì‚¬ ê°•ë„ ì¤„ì´ê¸°
      water.material.uniforms.waterColor.value.set(0x003030); // âœ… ë¬¼ ìƒ‰ìƒì„ ë” ì–´ë‘¡ê²Œ ì¡°ì •
      water.material.reflectivity = 0.0; //
      water.material.depthWrite = false;


      water.renderOrder = 3

    const numParticles = AMOUNTX * AMOUNTY;

    const positions = new Float32Array(numParticles * 3);
    const scales = new Float32Array(numParticles);

    let i = 0, j = 0;

    for (let ix = 0; ix < AMOUNTX; ix++) {
     for (let iy = 0; iy < AMOUNTY; iy++) {
      positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2); // X ì¢Œí‘œ
      positions[i + 1] = 0; // Y ì¢Œí‘œ (ê¸°ë³¸ê°’)
      positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2); // Z ì¢Œí‘œ
      scales[j] = 1;
      i += 3;
      j++;
     }
    }

    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    geometry.setAttribute('scale', new BufferAttribute(scales, 1));

    const material = new ShaderMaterial({
     uniforms: { color: { value: new Color(0xffffff) } },
     vertexShader: `
      attribute float scale;
      void main() {
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
       gl_PointSize = scale * (50.0 / -mvPosition.z);
       gl_Position = projectionMatrix * mvPosition;
      }
  `  ,
     fragmentShader: `
       uniform vec3 color;
       void main() {
        float distance = length(gl_PointCoord - vec2(0.5, 0.5));
        if (distance > 0.475) discard; // ì›í˜• ìœ ì§€
        gl_FragColor = vec4(color, 1.0);
       }
    `,
     depthTest: true,      // âœ… ê¹Šì´ í…ŒìŠ¤íŠ¸ ì ìš©
     depthWrite: true,     // âœ… ê¹Šì´ ë²„í¼ì— ê¸°ë¡
     transparent: false  
     });

     particles = new Points(geometry, material);
     scene.add(particles);

     setTimeout(() => {
     particles.material.depthTest = true;      // âœ… ê¹Šì´ í…ŒìŠ¤íŠ¸ í™œì„±í™”
     particles.material.depthWrite = true;     // âœ… ê¹Šì´ ë²„í¼ ê¸°ë¡
     particles.material.opacity = 1.0;   // âœ… íˆ¬ëª…ë„ ì œê±°
     particles.material.polygonOffset = true;
     particles.material.polygonOffsetFactor = -5.0;
     particles.material.polygonOffsetUnits = -5.0;
     particles.renderOrder = 2;
     particles.material.needsUpdate = true;
     }, 100);


    // ëª¨ë¸(FBX) ë¡œë“œ
    const loader = new GLTFLoader();
    loader.load(
     './models/FrankieObjects.gltf',
     function (gltf) {
      gltf.scene.position.set(97, 220, 200);   // ì›í•˜ëŠ” ì¢Œí‘œë¡œ ë°°ì¹˜
      gltf.scene.traverse((child) => {
       if (child.isMesh) {
        const originalMaterial = child.material;
        child.material = new MeshPhysicalMaterial({
         map: originalMaterial.map ?? null,  // ì›ë˜ ë² ì´ìŠ¤ ì»¬ëŸ¬ í…ìŠ¤ì²˜ ìœ ì§€
         normalMap: originalMaterial.normalMap ?? null,  // ì›ë˜ ë…¸ë©€ë§µ ìœ ì§€
         roughnessMap: originalMaterial.roughnessMap ?? null,  // ì›ë˜ ê±°ì¹ ê¸° ë§µ ìœ ì§€
         metalnessMap: originalMaterial.metalnessMap ?? null,      // ê¸°ë³¸ ìƒ‰ìƒ (í°ìƒ‰ ìœ ì§€)
         metalness: 0.18,       // ë°˜ì‚¬ íš¨ê³¼ (0~1) â†’ ë°˜ì§ì´ê²Œ ì„¤ì • ê°€ëŠ¥
         roughness: 0.9,       // í‘œë©´ ê±°ì¹ ê¸° (ë‚®ì„ìˆ˜ë¡ ë°˜ì‚¬ ë†’ì•„ì§)
         transmission: 0,    // ìœ ë¦¬ ê°™ì€ íˆ¬ëª… íš¨ê³¼ (0~1)
         ior: 1.5,             // êµ´ì ˆë¥  (ìœ ë¦¬ 1.5, ë¬¼ 1.33)
         clearcoat: 0.5,       // í‘œë©´ ì½”íŒ… íš¨ê³¼
         clearcoatRoughness: 0.1,
         reflectivity: 0.3,    // ë¹› ë°˜ì‚¬ìœ¨ (0~1)
         envMapIntensity: 0.8, // HDR í™˜ê²½ ë°˜ì‚¬ ê°•ë„
         transparent: false,
         opacity: 0.5,
        });
       }
      });
      gltf.scene.scale.set(0.09, 0.09, 0.09); // ìŠ¤ì¼€ì¼ë„ ì ì ˆíˆ
      gltf.scene.rotation.y = Math.PI; 
      // ì½œë°± ë‚´ë¶€ì—ì„œë§Œ objectì— ì ‘ê·¼ ê°€ëŠ¥
      scene.add(gltf.scene);

      window.addEventListener('click', (event) => {
      // ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì •ê·œí™”
       mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
       mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycasting ìˆ˜í–‰
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(gltf.scene, true);

      // í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ê°€ ìˆì„ ê²½ìš° nextpage.htmlë¡œ ì´ë™
      if (intersects.length > 0) {
        console.log("GLTF ì˜¤ë¸Œì íŠ¸ í´ë¦­ë¨!");
        window.location.href = 'Lookbook.html'; // ğŸ“Œ ë¡œì»¬ HTML íŒŒì¼ë¡œ ì´ë™
       }
      });


      const xyzLoader = new XYZLoader();
      xyzLoader.load('./models/points.xyz', (geometry) => {
      const material = new PointsMaterial({ color: 0xffffff, size: 0.15, sizeAttenuation: true,
        depthTest: false, opacity: 0.3, transparent: true });
        geometry.rotateX(Math.PI / 2);
       
      
      points = new Points(geometry, material);
      points.position.set(98.8, 223, 160); // GLTF ëª¨ë¸ê³¼ ê°™ì€ ìœ„ì¹˜ë¡œ ë§ì¶”ê¸°
      points.scale.set(20, 20, 20);
      scene.add(points);
      });

      // glTF ë¡œë”© ì½œë°± ë‚´ë¶€, scene.add(gltf.scene) ì§í›„
      const box = new Box3().setFromObject(gltf.scene);
      const center = box.getCenter(new Vector3());
      const sphere = new Sphere();
      box.getBoundingSphere(sphere);
      // OrbitControlsì— ëª¨ë¸ ì¤‘ì‹¬ì„ íƒ€ê²Ÿìœ¼ë¡œ ì§€ì •
      controls.target.set(center.x, center.y, center.z);

      // ì¹´ë©”ë¼ë¥¼ ëª¨ë¸ ì¤‘ì‹¬ì—ì„œ ë°˜ê²½ * 2 ì •ë„ ë–¨ì–´ì§„ ê³³ìœ¼ë¡œ ì´ë™
      camera.position.set(
      center.x,center.y,center.z + sphere.radius * 2
      );
      camera.updateProjectionMatrix();
      controls.update();
      console.log('Model center:', center);
      

      // â†’ glowMesh ìƒì„±ë„ ì—¬ê¸°ì„œ!
      const glowMaterial = new MeshBasicMaterial({
       color: 0xffff00, // ì›í•˜ëŠ” ë°œê´‘ ìƒ‰ìƒ (ë…¸ë€ìƒ‰)
       transparent: true,
       opacity: 0.5
     });
      const glowGeometry = new SphereGeometry(0.1, 32, 32);
      const glowMesh = new Mesh(glowGeometry, glowMaterial);
       glowMesh.position.set(0, 0, 0);
       glowMesh.layers.set(1); // bloom ë ˆì´ì–´
       // ì˜¤ë¸Œì íŠ¸ì— ìì‹ìœ¼ë¡œ ì¶”ê°€
       gltf.scene.add(glowMesh);


    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const fxaaPass = new ShaderPass(FXAAShader);
    fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
    composer.addPass(fxaaPass);
  },
  undefined,  // onProgress
  function (error) {
    console.error('GLTF ë¡œë”© ì˜¤ë¥˜:', error);
  }
);
            
     
    // ëª¨ë¸ì„ ê°•ì¡°í•˜ëŠ” ì¡°ëª… ì¶”ê°€
    const pointLight = new PointLight(0xffffff, 3, 100);
    pointLight.position.set(0, 0, 50); // ëª¨ë¸ ìœ„ìª½ ì¡°ëª… ì¶”ê°€
    scene.add(pointLight)
   
    initPostProcessing();

      animate();
    });
  }
    function initPostProcessing() {
      const renderPass = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(
        new Vector2(window.innerWidth, window.innerHeight),
        0.05,   // bloom ê°•ë„
        0.2,   // bloom ë°˜ê²½
        1.35   // bloom ì„ê³„ê°’
      );
      bloomPass.resolution.set(window.innerWidth / 2, window.innerHeight / 2);
      composer = new EffectComposer(renderer);
      composer.addPass(renderPass);
      composer.addPass(bloomPass);
    }


    function animate() {
      requestAnimationFrame(animate);
      
      if (water) {
        water.material.uniforms['time'].value += 0.05;
      }
     
      if (points) {
        points.rotation.y += 0.03;
      }

      controls.update();
      const positions = particles.geometry.attributes.position.array;
      const scales = particles.geometry.attributes.scale.array;

      let i = 0, j = 0;
      for (let ix = 0; ix < AMOUNTX; ix++) {
       for (let iy = 0; iy < AMOUNTY; iy++) {
        positions[i + 1] = (Math.sin((ix + count) * 0.3) * 50) + (Math.sin((iy + count) * 0.5) * 50);
        scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 20 + (Math.sin((iy + count) * 0.5) + 1) * 20;
        i += 3;
        j++;
       }
      }
     particles.geometry.attributes.position.needsUpdate = true;
     particles.geometry.attributes.scale.needsUpdate = true;
     count += 0.1;
     renderer.render(scene, camera);
     composer.render();
    }

    function onWResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    init();

  </script>
</body>
</html>
