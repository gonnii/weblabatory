<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XYZ Point Cloud Viewer</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js"
            }
        }
    </script>
</head>
<body style="margin: 0; overflow: hidden; background-color: black;">
    <script type="module">
        import * as THREE from "three";

        // 1. ì”¬ ìƒì„±
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // ë°°ê²½ ê²€ì€ìƒ‰

        // 2. ì¹´ë©”ë¼ ì„¤ì •
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);
        camera.position.z = 1.8; // XYZ ë°ì´í„°ê°€ ìž˜ ë³´ì´ë„ë¡ ì¡°ì •

        // 3. ë Œë”ëŸ¬ ìƒì„±
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 4. XYZ ë°ì´í„° ë¡œë“œ ë° í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ìƒì„±
        fetch("points.xyz")
            .then(response => response.text())
            .then(data => {
                const points = [];
                const scaleFactor = 1000;
                const lines = data.split("\n");

                for (let line of lines) {
                    const [x, y, z] = line.split(" ").map(Number);
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }


                // 5. ì  í˜•íƒœë¡œ í‘œì‹œ
                const material = new THREE.PointsMaterial({
                color: 0xffffff,     // í°ìƒ‰ ì 
                size: 1,           // ðŸ”¥ í¬ì¸íŠ¸ í¬ê¸° ì¦ê°€
                sizeAttenuation: false,  // ðŸŒŸ ì¹´ë©”ë¼ ê±°ë¦¬ì— ë”°ë¼ í¬ê¸° ë³€í•˜ì§€ ì•Šë„ë¡
                transparent: true,   // íˆ¬ëª…ë„ ì¶”ê°€
                opacity: 0.7,         // ë¶ˆí•„ìš”í•œ íˆ¬ëª…í™” ë°©ì§€
                depthTest: true     // ê¹Šì´ í…ŒìŠ¤íŠ¸ í™œì„±í™”
                });

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);

                // 6. í•œ ë²ˆë§Œ ë Œë”ë§
                renderer.render(scene, camera);
            });

        // ì°½ í¬ê¸° ì¡°ì • ì‹œ ì—…ë°ì´íŠ¸
        window.addEventListener("resize", () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
